Minimizing Permutations
    In this problem, you are given an integer N, and a permutation, P of the integers from 1 to N, denoted as (a_1, a_2, ..., a_N). You want to rearrange the elements of the permutation into increasing order, repeatedly making the following operation:

    Select a sub-portion of the permutation, (a_i, ..., a_j), and reverse its order.
    Your goal is to compute the minimum number of such operations required to return the permutation to increasing order.

    Signature
    int minOperations(int[] arr)

    Input
    Array arr is a permutation of all integers from 1 to N, N is between 1 and 8

    Output
    An integer denoting the minimum number of operations required to arrange the permutation in increasing order

    Example
    If N = 3, and P = (3, 1, 2), we can do the following operations:
    Select (1, 2) and reverse it: P = (3, 2, 1).
    Select (3, 2, 1) and reverse it: P = (1, 2, 3).
    output = 2

My Thoughts:

Starting out, no idea how to approach -- at least through graphs
I remember from linear algebra that any permutation can be reduced to a series of pair-wise permutations (I think)

We can look at some simple examples

With 2 elements, the problem is trivial:

2,1 => 1,2 in 1 permutation

With 3 elements we have the following possible problems

1,2,3 (solved)
1,3,2 => 1,2,3 (1 permutation of 3,2)
    note: we could have done this in more
        3,1,2 (put 1 next to 2)
        1,3,2 (get 3 to the end but oops, we're back where we started aren't we)
        1,2,3
    so this gives us the idea of a permutation going back to where we started
        could we think of the intermediates along the way as nodes? **
2,1,3
2,3,1
3,1,2
3,2,1

** So let's follow that thought of intermediate permutations being nodes, where we can get from one permutation to another through a series of intermediates -- then it's clear if we build a graph mapping all the permutations, we can find the shortest path!

Then we would need an algorithm to blindly generate a graph for a given set of all permutations, take the permutation we're given as our source, and find the path to the destination using BFS (which can be used to find the shortest path)

But how do we even generate the graph?